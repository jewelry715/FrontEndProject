<!DOCTYPE html>
<html>
<head>
 <style>
*{
    padding:0;
    margin: 0;
}
body{
    background-size: cover;
    background-position: center;
    box-sizing: border-box;
}

.menubar{
    top:20px;
    position: relative;
    background-color: #92A8D1;
    text-align: center;

}
.menubar>ul{
    display: inline-flex;
    list-style: none;
    color: #fff;
}
.menubar ul li{
    width: 120px;
    margin: 10px;
    padding:10px;
    list-style: none;
}
.menubar ul li a{
    text-decoration:none;
    color:#fff;
}
.active,.menubar ul li:hover{
    /* background: #FCC89B; */
    border-radius: 3;
}
.sub-menu-1{
    display:none;
}
.menubar ul li:hover .sub-menu-1{
    display: block;
    position: absolute;
    background:#b4b5df ;
    margin-top:15px;
    margin-left:15px ;
}
.menubar ul li:hover .sub-menu-1 ul{
    display: block;
    margin: 10px;
}
.menubar ul li:hover .sub-menu-1 ul li{
    width: 150px;
    padding: 10px;
    border-bottom: 1px dotted #fff;
    background: transparent;
    text-align: left;
}
.menubar ul li:hover .sub-menu-1 ul li:last-child{
    border-bottom: none;
}
.menubar ul li:hover .sub-menu-1 ul a:hover{
    color: blue;
}
.sub-menu-2{
    display:none;
}
.menubar ul li:hover .sub-menu-2{
    display: block;
    position: absolute;
    background: #a0d1ca;
    margin-top:15px;
    margin-left:15px ;
}
.menubar ul li:hover .sub-menu-2 ul{
    display: block;
    margin: 10px;
}
.menubar ul li:hover .sub-menu-2 ul li{
    width: 150px;
    padding: 10px;
    border-bottom: 1px dotted #fff;
    background: transparent;
    text-align: left;
}
.menubar ul li:hover .sub-menu-2 ul li:last-child{
    border-bottom: none;
}
.menubar ul li:hover .sub-menu-2 ul a:hover{
    color: blue;
}
.sub-menu-3{
    display:none;
}
.menubar ul li:hover .sub-menu-3{
    display: block;
    position: absolute;
    background: #987dd4;
    margin-top:15px;
    margin-left:15px ;
}
.menubar ul li:hover .sub-menu-3 ul{
    display: block;
    margin: 10px;
}
.menubar ul li:hover .sub-menu-3 ul li{
    width: 150px;
    padding: 10px;
    border-bottom: 1px dotted #fff;
    background: transparent;
    text-align: left;
}
.menubar ul li:hover .sub-menu-3 ul li:last-child{
    border-bottom: none;
}
.menubar ul li:hover .sub-menu-3 ul a:hover{
    color: blue;
}
.sub-menu-4{
    display:none;
}
.menubar ul li:hover .sub-menu-4{
    display: block;
    position: absolute;
    background: #ff8da1;
    margin-top:15px;
    margin-left:15px ;
}
.menubar ul li:hover .sub-menu-4 ul{
    display: block;
    margin: 10px;
}
.menubar ul li:hover .sub-menu-4 ul li{
    width: 150px;
    padding: 10px;
    border-bottom: 1px dotted #fff;
    background: transparent;
    border-radius: 0;
    text-align: left;
}
.menubar ul li:hover .sub-menu-4 ul li:last-child{
    border-bottom: none;
}
.menubar ul li:hover .sub-menu-4 ul a:hover{
    color: blue;
}
.inCanvas{
    margin-left: auto;
}
.outCanvas{
    margin-right: auto;
}
.input-file-button{ 
        padding: 6px 30px;
        background-color:#92A8D1;
        border-radius: 4px;
        color: white;
        cursor: pointer;
        position:fixed;
        text-align: center;
        float:right;
        bottom:75px;
        right:10px;
        width:50px;
}
h1{
    position: relative;
    top: 10px;
}
    </style> 
    <script>
        //전역변수부
        let inCanvas,inCtx,inPaper; //입력영상관련
        let outCanvas,outCtx,outPaper; //출력 영상 관련
        let inImage,inH,inW; //2차원배열, 높이, 폭
        let outImage,outH,outW; //2차원배열, 높이, 폭
        let inFile;
        //공통함수부:open(),display().....
        function init(){
            inCanvas = document.getElementById("inCanvas"); // 도화지
            inCtx = inCanvas.getContext("2d"); // 물감, 붓이 들은 통
            outCanvas = document.getElementById("outCanvas"); // 도화지
            outCtx = outCanvas.getContext("2d"); // 물감, 붓이 들은 통
        }      
        function openImage(){
            inFile = document.getElementById("inFile").files[0]; // 선택한 RAW 파일(LENNA512.RAW)
            // (중요!) 선택한 이미지의 크기를 확인
            inH = inW = Math.sqrt(inFile.size); // 128, 256, 512, 1024.....
            // 이미지 크기의 메모리(2차원배열)를 확보
            inImage = new Array(inH);
            for(let i=0; i<inH; i++)
                inImage[i] = new Array(inW);
            // 파일  --> 메모리
            let reader = new FileReader();
            reader.readAsBinaryString(inFile);
            reader.onload = function () {
                let blob = reader.result; // 파일을 한 덩어리(blob)으로 가져옴.
                // 덩어리(blob)에서 한점한점 뽑아서, 배열에 넣기... 몇번 반복? 512x512
                for (let i=0; i<inH; i++) {
                    for (let k=0; k<inW; k++) {
                        let sPixel = (i*inH + k); // 시작 위치
                        let ePixel = (i*inH + k) + 1; // 끝 위치
                        inImage[i][k] = blob.slice(sPixel,ePixel).charCodeAt(0); // 0~1까지 뽑아라. 0만 뽑힘.  //'뙓' -->  223
                    }
                }
                // 도화기 크기를 이미지 크기로 조절
                inCanvas.height = inH;
                inCanvas.width = inW;
                //** 입력 메모리(inImage)를 페이퍼에 콕콕 찍어서 출력한 후,  페이퍼를 캔버스에 떡 붙이기.
                inPaper= inCtx.createImageData(inH, inW); // 이미지 크기의 빈 종이를 준비
                for (let i=0; i<inH; i++) {
                    for (let k=0; k<inW; k++) {
                        let px = inImage[i][k];
                        inPaper.data[(i*inH + k)*4 + 0] = px; // Red
                        inPaper.data[(i*inH + k)*4 + 1] = px; // Green
                        inPaper.data[(i*inH + k)*4 + 2] = px; // Blue
                        inPaper.data[(i*inH + k)*4 + 3] = 255; // Alpha (투명도)
                    }
                }
                inCtx.putImageData(inPaper,0,0);
            }
        }
        function displayImage(){
            outCanvas.height = outH;
            outCanvas.width = outW;

            outPaper= outCtx.createImageData(outH, outW); // 이미지 크기의 빈 종이를 준비
            for (let i=0; i<outH; i++) {
                for (let k=0; k<outW; k++) {
                    let px = outImage[i][k];  
                    outPaper.data[(i*outH + k)*4 + 0] = px; // Red
                    outPaper.data[(i*outH + k)*4 + 1] = px; // Green
                    outPaper.data[(i*outH + k)*4 + 2] = px; // Blue
                    outPaper.data[(i*outH + k)*4 + 3] = 255; // Alpha (투명도)
                }
            }
            outCtx.putImageData(outPaper,0,0); //딱맞게끔 붙여라.
        }    
        function selectAlgorithm(selNum){
            switch (parseInt(selNum.value)){
                case 101: //동일영상
                    equalImage();break;
                case 102: //반전영상
                    reverseImage();break;
                case 103: //더하기
                    brightImage();break;
                case 104: //빼기
                    darkImage();break;
                case 105: //곱하기
                    multiplyImage();break;
                case 106: //나누기
                    divideImage();break;
                case 107: //흑백 평균
                    averageImage();break;
                case 108: //흑백(127)
                    blackwhiteImage();break;
                case 109: //감마
                    break;
                case 110: //파라볼라(캡)
                    paraCap();break;
                case 111:
                    paraCup();break;
                case 201: //상하 미러링
                    updownImage();break;
                case 202: //좌우 미러링
                    leftrightImage();break;
                case 203: //확대 미러링
                    zoomInImage();break;
                case 204: //확대 미러링(백워딩)
                    zoomInImage2();break;
                case 205: //축소 미러링
                    zoomOutImage();break;
                case 206: //회전
                    rotateImage();break;
                case 207: //이동
                    moveImage();break;
                case 301: //엠보싱
                    embossImage();break;
                case 302: //블러링
                    blurrImage();break;
                case 303: //샤프닝
                    sharpening();break;
                case 304: //고주파샤프닝
                    OnHpfSharp();break;
                case 305: //수평검출
                    horizon();break;
                case 306: //수직검출
                    vertical();break;
                case 307: //가우시안
                    gaussian();break;
                case 308: //유사연산자 에지검출
                    OnHomogenOperator();break;
                case 309: //라플라시안
                    laplacian();break;
                case 401: //스트레칭
                    stretchImage();break;
                case 402: //엔드-인
                    endInImage();break;
                case 403://평활화
                    equalizeImage();break;
            }
        }
        //영상처리 함수부
        function equalImage(){
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    outImage[i][k] = inImage[i][k];
                }
            }
            // ******************************
            displayImage();
        } 
        function reverseImage(){//영상반전 알고리즘
                // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
                outH = inH;
                outW = inW;
                // 출력 영상의 2차원 메모리 할당
                outImage = new Array(outH);
                for(let i=0; i<outH; i++)
                    outImage[i] = new Array(outW);
                // **** 진짜 영상처리 알고리즘 *****
                for (let i=0; i<inH; i++) {
                    for (let k=0; k<inW; k++) {
                        outImage[i][k] = 255 - inImage[i][k];
                    }
                }
                // ******************************
                displayImage();
            } 
        function brightImage(){ //밝게,더하기
            outH = inH;
            outW = inW;
            let num=parseInt(prompt("더할값",""))
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    outImage[i][k] = inImage[i][k]+num;
                    if(outImage[i][k]>255){
                        outImage[i][k]=255;
                    }
                }
            }
            // ******************************
            displayImage();
        }
        function darkImage(){ //어둡게,빼기
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);     
            let num=parseInt(prompt("뺄값",""))
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    outImage[i][k] = inImage[i][k]-num;
                    if(outImage[i][k]<0){
                        outImage[i][k]=0;
                    }
                }
            }
            // ******************************
            displayImage();
        }
        function multiplyImage(){ //곱하기
            outH = inH;
            outW = inW;
            let num=parseInt(prompt("곱할값",""));
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    outImage[i][k] = inImage[i][k]*num;
                    if(outImage[i][k]<0){
                        outImage[i][k]=0;
                    }
                    else if(outImage[i][k]>255){
                        outImage[i][k]=255;
                    }
                }
            }
            displayImage();
        }
        // ******************************
        function divideImage(){ //나누기
            outH = inH;
            outW = inW;
            let num=parseInt(prompt("0을 제외한 값을 입력하시오",""));
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    outImage[i][k] = inImage[i][k]/num;
                    if(num!=0){
                        if(outImage[i][k]<0){
                            outImage[i][k]=0;
                        }
                        else if(outImage[i][k]>255){
                            outImage[i][k]=255;
                        }
                    }
                    else{
                        document.write();
                    }
                }
            }
            displayImage();
        }       
        function blackwhiteImage(){ //흑백미러링
                outH = inH;
                outW = inW;
                // 출력 영상의 2차원 메모리 할당
                outImage = new Array(outH);
                for(let i=0; i<outH; i++)
                    outImage[i] = new Array(outW);
                // **** 진짜 영상처리 알고리즘 *****
                for (let i=0; i<inH; i++) {
                    for (let k=0; k<inW; k++) {
                        if (inImage[i][k]<=127)
                            outImage[i][k] =0;
                        else{
                            outImage[i][k] =255;
                        }
                    }
                }
                // ******************************
                displayImage();
            }
            // ******************
        function averageImage(){ //흑백미러링(평균)
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            //평균 계산
            let sum=0;
            let avg=0;
            for(let i=0;i<inH;i++){
                for(let k=0;k<inW;k++){
                    sum+=inImage[i][k];
                }
            }
            avg=sum/(inH*inW);
            // **** 진짜 영상처리 알고리즘 *****
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    if (inImage[i][k]<=avg)
                        outImage[i][k] =0;
                    else{
                        outImage[i][k] =255;
                    }
                }
            }
            // ******************************
            displayImage();
        }
        function gammaImage(){ //감마
            outH = inH;
            outW = inW;
            let gamma=parseFloat(prompt("감마를 입력하세요"))
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    outImage[i][k] = Math.pow(inImage[i][k]/255, gamma) * 255;
                    if(outImage[i][k]>255)
                        outImage[i][k]=255;
                    else if(outImage[i][k]<0){
                        outImage[i][k]=0;
                    }
                }
            }
            // ******************************
            displayImage();
        }
        // ******************************
        function paraCap(){//파라볼라(캡)
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            //out=255*(in/127-1)**2
            let LUT=new Array(256);
            //미리 계산해놓기
            for(let i=0;i<256;i++){
                LUT[i]=Math.pow((i/127.0 -1), 2) * 255.0;
            }
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    //outImage[i][k] = Math.pow((inImage[i][k]/127.0 -1), 2) * 255.0;//캡
                    outImage[i][k]=LUT[inImage[i][k]];
                }
            }
            // ******************************
            displayImage();
        }
        // ******************************
        function paraCup(){//파라볼라(컵)
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    outImage[i][k] = 255.0-Math.pow((inImage[i][k]/127.0 -1), 2) * 255.0;
                }
            }
            // ******************************
            displayImage();
        }
            // ****************************** 
        function updownImage(){ //상하미러링
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    outImage[i][k] = inImage[inH-1-i][k];
                }
            }
            // ******************************
            displayImage();
        }
        function leftrightImage(){ //좌우미러링
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    outImage[i][k] = inImage[i][inW-1-k];
                }
            }
            // ******************************
            displayImage();
        }
        function zoomInImage(){//확대알고리즘
                let scale=parseInt(prompt("배율","2"));
                outH = parseInt(inH*scale);
                outW = parseInt(inW*scale);
                // 출력 영상의 2차원 메모리 할당
                outImage = new Array(outH);
                for(let i=0; i<outH; i++)
                    outImage[i] = new Array(outW);
                // **** 진짜 영상처리 알고리즘 *****
                for (let i=0; i<inH; i++) {
                    for (let k=0; k<inW; k++) {
                        outImage[parseInt(i*scale)][parseInt(k*scale)]=inImage[i][k];
                    }
                }
                // ******************************
                displayImage();
            }
        function zoomInImage2(){//확대알고리즘,백워딩
            let scale=parseInt(prompt("배율","2"));
            outH = parseInt(inH*scale);
            outW = parseInt(inW*scale);
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            for (let i=0; i<outH; i++) {
                for (let k=0; k<outW; k++) {
                    outImage[i][k]=inImage[parseInt(i/scale)][parseInt(k/scale)];
                }
            }
            // ******************************
            displayImage();
        }
        // ******************************
        function zoomOutImage(){//축소알고리즘
            let scale=parseInt(prompt("배율","2"));
            outH = parseInt(inH/scale);
            outW = parseInt(inW/scale);
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    outImage[parseInt(i/scale)][parseInt(k/scale)]=inImage[i][k];
                }
            }
            // ******************************
            displayImage();
        }
        function rotateImage(){//회전 알고리즘
                outH = inH;
                outW = inW;
                // 출력 영상의 2차원 메모리 할당
                outImage = new Array(outH);
                for(let i=0; i<outH; i++)
                    outImage[i] = new Array(outW);
                //초기화
                for(let i=0;i<outH;i++){
                    for(let k=0;k<outW;k++){
                        outImage[i][k]=255;
                    }
                }
                let angle=parseInt(prompt("각도 입력","45"));
                let radian=Math.PI*angle/180.0;
                //xout=cos*xin-sin*yin
                //yout=cos*yin+sin*xin
                let cx = parseInt(outH/2);
                let cy = parseInt(outW/2);

                // **** 진짜 영상처리 알고리즘 *****
                for (let i=0; i<outH; i++) { //xs
                    for (let k=0; k<outW; k++) { //ys
                        let xin=parseInt(Math.cos(radian)*(i-cx)+Math.sin(radian)*(k-cy)+cx);
                        let yin=parseInt(-Math.sin(radian)*(i-cx)+Math.cos(radian)*(k-cy)+cy);
                        if ((0 <= xin && xin < inW) && (0 <= yin && yin < inH))
                            outImage[i][k]=inImage[xin][yin];
                    }
                }
                // ******************************
                displayImage();
            }
        function moveImage(){//이동
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);

            // **** 진짜 영상처리 알고리즘 *****
            let valueStr=prompt("이동(x,y)","50,100"); 
            let valueAry=valueStr.split(",");
            let x_val=parseInt(valueAry[0]);
            let y_val=parseInt(valueAry[1]);

            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    if((0<=i+x_val&&i+x_val<outW) && 
                        (0<=k+y_val&&k+y_val<outH))
                        outImage[i+x_val][k+y_val]=inImage[i][k];
                }
            }
            displayImage();
        }
    //영상처리 함수부
    function embossImage(){ //엠보싱 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            //(중요함) --> 마스크를 선택
            let mask=[[-1.0,0.0,0.0],
                    [0.0,0.0,0.0],
                    [0.0,0.0,1.0]]; //원칙.영상학자들이 만든 것임.
            //임시 입력 배열(입력배열+2)
            let tmpInImage=new Array(inH+2);
            for(let i=0;i<inH+2;i++)
                tmpInImage[i]=new Array(inW+2);
            //임시 출력 배열(출력배열과 크기 동일)
            let tmpOutImage = new Array(outH);
            for(let i=0; i<outH; i++)
                tmpOutImage[i] = new Array(outW);
            //임시입력배열 초기화(127,평균값,인접값*)
            for (let i=0; i<inH+2; i++) 
                for (let k=0; k<inW+2; k++)
                    tmpInImage[i][k] = 127.0; //회색으로 처리하는게 나음.
                    //너무 밝게하거나 어둡게 하면 안나옴.
            //입력 이미지를 임시 입력이미지의 중간에 들어가기
            for(let i=0;i<inH;i++)
                for(let k=0;k<inW;k++)
                    tmpInImage[i+1][k+1]=inImage[i][k]
            //영상처리 알고리즘 구현->회선 연산(=긁어가기)
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    //한점처리
                    let s=0.0; //9점을 곱해서 합한 결과
                    for(var m=0;m<3;m++)
                        for(var n=0;n<3;n++)
                            s+=tmpInImage[i+m][k+n]*mask[m][n];
                    tmpOutImage[i][k]=s;
                    
                }
            }
            //후처리 작업(마스크의 합계가 0이면...127정도를 더해주기를 고려)
            for (let i=0; i<outH; i++) {
                for (let k=0; k<outW; k++) {
                    tmpOutImage[i][k]+=127.0;
                }
            }
            //임시 출력 이미지->원 출력 이미지
            for (let i=0; i<outH; i++) 
                for (let k=0; k<outW; k++) {
                    if(tmpOutImage[i][k]>255.0)
                        outImage[i][k]=255;
                    else if(tmpOutImage[i][k]<0.0)
                        outImage[i][k]=0;
                    else
                        outImage[i][k]=parseInt(tmpOutImage[i][k]);
                }
            // ******************************
            displayImage();
        } 
        
    function blurrImage(){ //엠보싱 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            //(중요함) --> 마스크를 선택
            let mask=[[1.0/9,1.0/9,1.0/9],
                    [1.0/9,1.0/9,1.0/9],
                    [1.0/9,1.0/9,1.0/9]];
            //임시 입력 배열(입력배열+2)
            let tmpInImage=new Array(inH+2);
            for(let i=0;i<inH+2;i++)
                tmpInImage[i]=new Array(inW+2);
            //임시 출력 배열(출력배열과 크기 동일)
            let tmpOutImage = new Array(outH);
            for(let i=0; i<outH; i++)
                tmpOutImage[i] = new Array(outW);
            //임시입력배열 초기화(127,평균값,인접값*)
            for (let i=0; i<inH+2; i++) 
                for (let k=0; k<inW+2; k++)
                    tmpInImage[i][k] = 127.0;
            //입력 이미지를 임시 입력이미지의 중간에 들어가기
            for(let i=0;i<inH;i++)
                for(let k=0;k<inW;k++)
                    tmpInImage[i+1][k+1]=inImage[i][k]
            //영상처리 알고리즘 구현->회선 연산(=긁어가기)
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    //한점처리
                    let s=0.0; //9점을 곱해서 합한 결과
                    for(var m=0;m<3;m++)
                        for(var n=0;n<3;n++)
                            s+=tmpInImage[i+m][k+n]*mask[m][n];
                    tmpOutImage[i][k]=s;
                    
                }
            }
            //후처리 작업(마스크의 합계가 0이면...127정도를 더해주기를 고려)
            // for (let i=0; i<outH; i++) {
            //     for (let k=0; k<outW; k++) {
            //         tmpOutImage[i][k]+=127.0;
            //     }
            // }
            //임시 출력 이미지->원 출력 이미지
            for (let i=0; i<outH; i++) 
                for (let k=0; k<outW; k++) {
                    if(tmpOutImage[i][k]>255.0)
                        outImage[i][k]=255;
                    else if(tmpOutImage[i][k]<0.0)
                        outImage[i][k]=0;
                    else
                        outImage[i][k]=parseInt(tmpOutImage[i][k]);
                }
            // ******************************
            displayImage();
        }
    function sharpening(){ //샤프닝 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            //(중요함) --> 마스크를 선택
            let mask=[[-1.0,-1.0,-1.0],
                    [-1.0,9.0,-1.0],
                    [-1.0,-1.0,-1.0]]
            //임시 입력 배열(입력배열+2)
            let tmpInImage=new Array(inH+2);
            for(let i=0;i<inH+2;i++)
                tmpInImage[i]=new Array(inW+2);
            //임시 출력 배열(출력배열과 크기 동일)
            let tmpOutImage = new Array(outH);
            for(let i=0; i<outH; i++)
                tmpOutImage[i] = new Array(outW);
            //임시입력배열 초기화(127,평균값,인접값*)
            for (let i=0; i<inH+2; i++) 
                for (let k=0; k<inW+2; k++)
                    tmpInImage[i][k] = 127.0;
            //입력 이미지를 임시 입력이미지의 중간에 들어가기
            for(let i=0;i<inH;i++)
                for(let k=0;k<inW;k++)
                    tmpInImage[i+1][k+1]=inImage[i][k]
            //영상처리 알고리즘 구현->회선 연산(=긁어가기)
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    //한점처리
                    let s=0.0; //9점을 곱해서 합한 결과
                    for(var m=0;m<3;m++)
                        for(var n=0;n<3;n++)
                            s+=tmpInImage[i+m][k+n]*mask[m][n];
                    tmpOutImage[i][k]=s;
                }
            }
            for (let i=0; i<outH; i++) 
                for (let k=0; k<outW; k++) {
                    if(tmpOutImage[i][k]>255.0)
                        outImage[i][k]=255;
                    else if(tmpOutImage[i][k]<0.0)
                        outImage[i][k]=0;
                    else
                        outImage[i][k]=parseInt(tmpOutImage[i][k]);
                }
            // ******************************
            displayImage();
        }
    function OnHpfSharp(){ //고주파 샤프닝 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            //(중요함) --> 마스크를 선택
            let mask=[[-1/9.,-1/9.,-1/9.],
                    [-1/9.,8/9.,-1/9.],
                    [-1/9.,-1/9.,-1/9.]]
            //임시 입력 배열(입력배열+2)
            let tmpInImage=new Array(inH+2);
            for(let i=0;i<inH+2;i++)
                tmpInImage[i]=new Array(inW+2);
            //임시 출력 배열(출력배열과 크기 동일)
            let tmpOutImage = new Array(outH);
            for(let i=0; i<outH; i++)
                tmpOutImage[i] = new Array(outW);
            //임시입력배열 초기화(127,평균값,인접값*)
            for (let i=0; i<inH+2; i++) 
                for (let k=0; k<inW+2; k++)
                    tmpInImage[i][k]=127.0;
            //입력 이미지를 임시 입력이미지의 중간에 들어가기
            for(let i=0;i<inH;i++)
                for(let k=0;k<inW;k++)
                    tmpInImage[i+1][k+1]=inImage[i][k]
            //영상처리 알고리즘 구현->회선 연산(=긁어가기)
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    //한점처리
                    let s=0.0; //9점을 곱해서 합한 결과
                    for(var m=0;m<3;m++)
                        for(var n=0;n<3;n++)
                            s+=20*mask[m][n]*tmpInImage[i+m][k+n];
                    tmpOutImage[i][k]=s;
                }
            }
            // **** 진짜 영상처리 알고리즘 *****
            for (let i=0; i<outH; i++) 
                for (let k=0; k<outW; k++) {
                    if(tmpOutImage[i][k]>255.0)
                        outImage[i][k]=255;
                    else if(tmpOutImage[i][k]<0.0)
                        outImage[i][k]=0;
                    else
                        outImage[i][k]=parseInt(tmpOutImage[i][k]);
                }
            // ******************************
            displayImage();
        }
    function horizon(){ //수평검출 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            //(중요함) --> 마스크를 선택
            let mask=[[0.0,-1.0,0.0],
                    [0.0,1.0,0.0],
                    [0.0,0.0,0.0]];
            //임시 입력 배열(입력배열+2)
            let tmpInImage=new Array(inH+2);
            for(let i=0;i<inH+2;i++)
                tmpInImage[i]=new Array(inW+2);
            //임시 출력 배열(출력배열과 크기 동일)
            let tmpOutImage = new Array(outH);
            for(let i=0; i<outH; i++)
                tmpOutImage[i] = new Array(outW);
            //임시입력배열 초기화(127,평균값,인접값*)
            for (let i=0; i<inH+2; i++) 
                for (let k=0; k<inW+2; k++)
                    tmpInImage[i][k] = 127.0;
            //입력 이미지를 임시 입력이미지의 중간에 들어가기
            for(let i=0;i<inH;i++)
                for(let k=0;k<inW;k++)
                    tmpInImage[i+1][k+1]=inImage[i][k]
            //영상처리 알고리즘 구현->회선 연산(=긁어가기)
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    //한점처리
                    let s=0.0; //9점을 곱해서 합한 결과
                    for(var m=0;m<3;m++)
                        for(var n=0;n<3;n++)
                            s+=tmpInImage[i+m][k+n]*mask[m][n];
                    tmpOutImage[i][k]=s;
                }
            }
            for (let i=0; i<outH; i++) 
                for (let k=0; k<outW; k++) {
                    if(tmpOutImage[i][k]>255.0)
                        outImage[i][k]=255;
                    else if(tmpOutImage[i][k]<0.0)
                        outImage[i][k]=0;
                    else
                        outImage[i][k]=parseInt(tmpOutImage[i][k]);
                }
            // ******************************
            displayImage();
        }
    function vertical(){ //수직검출 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            //(중요함) --> 마스크를 선택
            let mask=[[0.0,0.0,0.0],
                    [-1.0,1.0,0.0],
                    [0.0,0.0,0.0]];
            //임시 입력 배열(입력배열+2)
            let tmpInImage=new Array(inH+2);
            for(let i=0;i<inH+2;i++)
                tmpInImage[i]=new Array(inW+2);
            //임시 출력 배열(출력배열과 크기 동일)
            let tmpOutImage = new Array(outH);
            for(let i=0; i<outH; i++)
                tmpOutImage[i] = new Array(outW);
            //임시입력배열 초기화(127,평균값,인접값*)
            for (let i=0; i<inH+2; i++) 
                for (let k=0; k<inW+2; k++)
                    tmpInImage[i][k] = 127.0;
            //입력 이미지를 임시 입력이미지의 중간에 들어가기
            for(let i=0;i<inH;i++)
                for(let k=0;k<inW;k++)
                    tmpInImage[i+1][k+1]=inImage[i][k]
            //영상처리 알고리즘 구현->회선 연산(=긁어가기)
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    //한점처리
                    let s=0.0; //9점을 곱해서 합한 결과
                    for(var m=0;m<3;m++)
                        for(var n=0;n<3;n++)
                            s+=tmpInImage[i+m][k+n]*mask[m][n];
                    tmpOutImage[i][k]=s;
                }
            }
            for (let i=0; i<outH; i++) 
                for (let k=0; k<outW; k++) {
                    if(tmpOutImage[i][k]>255.0)
                        outImage[i][k]=255;
                    else if(tmpOutImage[i][k]<0.0)
                        outImage[i][k]=0;
                    else
                        outImage[i][k]=parseInt(tmpOutImage[i][k]);
                }
            // ******************************
            displayImage();
        }        
    function gaussian(){ //가우시안 스무딩 필터처리 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            //(중요함) --> 마스크를 선택
            let mask=[[1.0/16,1.0/8,1.0/16],
                    [1.0/8,1.0/4,1.0/8],
                    [1.0/16,1.0/8,1.0/16]];
            //임시 입력 배열(입력배열+2)
            let tmpInImage=new Array(inH+2);
            for(let i=0;i<inH+2;i++)
                tmpInImage[i]=new Array(inW+2);
            //임시 출력 배열(출력배열과 크기 동일)
            let tmpOutImage = new Array(outH);
            for(let i=0; i<outH; i++)
                tmpOutImage[i] = new Array(outW);
            //임시입력배열 초기화(127,평균값,인접값*)
            for (let i=0; i<inH+2; i++) 
                for (let k=0; k<inW+2; k++)
                    tmpInImage[i][k] = 127.0;
            //입력 이미지를 임시 입력이미지의 중간에 들어가기
            for(let i=0;i<inH;i++)
                for(let k=0;k<inW;k++)
                    tmpInImage[i+1][k+1]=inImage[i][k]
            //영상처리 알고리즘 구현->회선 연산(=긁어가기)
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    //한점처리
                    let s=0.0; //9점을 곱해서 합한 결과
                    for(var m=0;m<3;m++)
                        for(var n=0;n<3;n++)
                            s+=tmpInImage[i+m][k+n]*mask[m][n];
                    tmpOutImage[i][k]=s;
                }
            }
            for (let i=0; i<outH; i++) 
                for (let k=0; k<outW; k++) {
                    if(tmpOutImage[i][k]>255.0)
                        outImage[i][k]=255;
                    else if(tmpOutImage[i][k]<0.0)
                        outImage[i][k]=0;
                    else
                        outImage[i][k]=parseInt(tmpOutImage[i][k]);
                }
            // ******************************
            displayImage();
        }        
    function OnHomogenOperator(){ //유사연산자 에지 검출 처리
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            //임시 입력 배열(입력배열+2)
            let tmpInImage=new Array(inH+2);
            for(let i=0;i<inH+2;i++)
                tmpInImage[i]=new Array(inW+2);
            //임시 출력 배열(출력배열과 크기 동일)
            let tmpOutImage = new Array(outH);
            for(let i=0; i<outH; i++)
                tmpOutImage[i] = new Array(outW);
            //임시입력배열 초기화(127,평균값,인접값*)
            for (let i=0; i<inH+2; i++) 
                for (let k=0; k<inW+2; k++)
                    tmpInImage[i][k] = 127.0;
            //입력 이미지를 임시 입력이미지의 중간에 들어가기
            for(let i=0;i<inH;i++)
                for(let k=0;k<inW;k++)
                    tmpInImage[i+1][k+1]=inImage[i][k]
            //영상처리 알고리즘 구현->회선 연산(=긁어가기)
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    //한점처리
                    let max=0.0; //9점을 곱해서 합한 결과
                    for(var m=0;m<3;m++)
                        for(var n=0;n<3;n++)
                            if(Math.abs(tmpInImage[i+1][k+1]-tmpInImage[i+m][k+n])>=max)
                                max=Math.abs(tmpInImage[i+1][k+1]-tmpInImage[i+m][k+n]);
                    //블록의 가운데값-블록의 주변 픽셀값의 절대값 중에서 최대값
                    tmpOutImage[i][k]=max;
                }
            }
            for (let i=0; i<outH; i++) 
                for (let k=0; k<outW; k++) {
                    if(tmpOutImage[i][k]>255.0)
                        outImage[i][k]=255;
                    else if(tmpOutImage[i][k]<0.0)
                        outImage[i][k]=0;
                    else
                        outImage[i][k]=parseInt(tmpOutImage[i][k]);
                }
            // ******************************
            displayImage();
        }
    function laplacian(){ //라플라시안 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            //(중요함) --> 마스크를 선택
            let mask=[[0.0,1.0,0.0],
                    [1.0,-4.0,1.0],
                    [0.0,1.0,0.0]];
            //임시 입력 배열(입력배열+2)
            let tmpInImage=new Array(inH+2);
            for(let i=0;i<inH+2;i++)
                tmpInImage[i]=new Array(inW+2);
            //임시 출력 배열(출력배열과 크기 동일)
            let tmpOutImage = new Array(outH);
            for(let i=0; i<outH; i++)
                tmpOutImage[i] = new Array(outW);
            //임시입력배열 초기화(127,평균값,인접값*)
            for (let i=0; i<inH+2; i++) 
                for (let k=0; k<inW+2; k++)
                    tmpInImage[i][k] = 127.0;
            //입력 이미지를 임시 입력이미지의 중간에 들어가기
            for(let i=0;i<inH;i++)
                for(let k=0;k<inW;k++)
                    tmpInImage[i+1][k+1]=inImage[i][k]
            //영상처리 알고리즘 구현->회선 연산(=긁어가기)
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    //한점처리
                    let s=0.0; //9점을 곱해서 합한 결과
                    for(var m=0;m<3;m++)
                        for(var n=0;n<3;n++)
                            s+=tmpInImage[i+m][k+n]*mask[m][n];
                    tmpOutImage[i][k]=s;
                }
            }
            for (let i=0; i<outH; i++) 
                for (let k=0; k<outW; k++) {
                    if(tmpOutImage[i][k]>255.0)
                        outImage[i][k]=255;
                    else if(tmpOutImage[i][k]<0.0)
                        outImage[i][k]=0;
                    else
                        outImage[i][k]=parseInt(tmpOutImage[i][k]);
                }
            // ******************************
            displayImage();
        }     
        //영상처리 함수부
        function stretchImage(){
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            //out=(oldpixel-low)/(high-low)*255.0
            let low=inImage[0][0], high=inImage[0][0];
            for (let i=0; i<inH; i++)
                for (let k=0; k<inW; k++) {
                    if(low>inImage[i][k])
                        low=inImage[i][k];
                    if(high<inImage[i][k])
                        high=inImage[i][k];
                }
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    let out=(inImage[i][k]-low)/(high-low)*255.0;
                    if(out<0.0)
                        out=0;
                    else if(out>255.0)
                        out=255;
                    else 
                        out=parseInt(out);
                    outImage[i][k]=out;
            }
        }
            // ******************************
            displayImage();
        }
    //영상처리 함수부
        function endInImage(){
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            //out=(oldpixel-low)/(high-low)*255.0
            let low=inImage[0][0], high=inImage[0][0];
            for (let i=0; i<inH; i++)
                for (let k=0; k<inW; k++) {
                    if(low>inImage[i][k])
                        low=inImage[i][k];
                    if(high<inImage[i][k])
                        high=inImage[i][k];
                }
            low+=50;
            high-=50;
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    let out=(inImage[i][k]-low)/(high-low)*255.0;
                    if(out<0.0)
                        out=0;
                    else if(out>255.0)
                        out=255;
                    else 
                        out=parseInt(out);
                    outImage[i][k]=out;
            }
        }
            // ******************************
            displayImage();
        }
        //영상처리 함수부
        function equalizeImage(){
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;
            // 출력 영상의 2차원 메모리 할당
            outImage = new Array(outH);
            for(let i=0; i<outH; i++)
                outImage[i] = new Array(outW);
            // **** 진짜 영상처리 알고리즘 *****
            // 1단계 : 히스토그램 생성
            let histo = new Array(256);
            // 초기화
            for(let i=0; i<256; i++)
                histo[i] =0;
            // 카운트
            for (let i=0; i<inH; i++) 
                for (let k=0; k<inW; k++) 
                    histo[inImage[i][k]] ++;
            // 2단계 : 누적히스토그램 생성
            let sumHisto = new Array(256);
            // 초기화
            for(let i=0; i<256; i++)
                sumHisto[i] =0;
            // 계산
            let sumValue = 0;
            for (let i=0; i<256; i++) {
                sumValue += histo[i];
                sumHisto[i] = sumValue;
            }
            // 3단계 : 정규화된 누적 히스토그램 생성
            // 공식 : normal = sum * (1.0 / (inH*inW) ) * 255;
            let normalHisto = new Array(256);
            // 초기화
            for(let i=0; i<256; i++)
                normalHisto[i] =0.0;
            // 계산
            for(let i=0; i<256; i++) {
                let normal = sumHisto[i] * (1.0 / (inH * inW)) * 255.0;
                normalHisto[i] = normal;
            }
            // 영상 처리
            for (let i=0; i<inH; i++) {
                for (let k=0; k<inW; k++) {
                    outImage[i][k] = parseInt(normalHisto[inImage[i][k]]);
                }
            }
            // ******************************
            displayImage();
        }
    </script>
    </head>
    <body onload=init() style="background-color:#F7CAC9;"> 
        <form>
            <h1 style="text-align:center; color:#92A8D1;">영상처리 프로그램(GA,RTM,1.0)</h1>
            <label class="input-file-button" for="inFile">업로드</label>
            <input type="file" id="inFile" onchange="openImage()" style="display:none;"><br>
            <div class="menubar">
                <ul>
                    <li class="menu">
                      <a href="#">화소점처리</a>
                      <div class="sub-menu-1">
                        <ul>
                            <li><a href="#" onclick="equalImage()">동일영상</a></li>
                            <li><a href="#" onclick="reverseImage()">영상반전</a></li>
                            <li><a href="#" onclick="brightImage()">더하기</a></li>
                            <li><a href="#" onclick="darkImage()">빼기</a></li>
                            <li><a href="#" onclick="multiplyImage()">곱하기</a></li>
                            <li><a href="#" onclick="divideImage()">나누기</a></li>
                            <li><a href="#" onclick="averageImage()">흑백(평균값)</a></li>
                            <li><a href="#" onclick="blackwhiteImage()">흑백(127)</a></li>
                            <li><a href="#" onclick="gammaImage()">감마</a></li>
                            <li><a href="#" onclick="paraCap()">파라볼라(캡)</a></li>
                            <li><a href="#" onclick="paraCup()">파라볼라(컵)</a></li>
                        </ul>
                    </div>
                    </li>
                    <li class="menu">
                      <a href="#">기하학처리</a>
                      <div class="sub-menu-2">
                        <ul class="submenu">
                            <li><a href="#" onclick="updownImage()">상하미러링</a></li>
                            <li><a href="#" onclick="leftrightImage()">좌우미러링</a></li>
                            <li><a href="#" onclick="zoomInImage()">확대미러링</a></li>
                            <li><a href="#" onclick="zoomInImage2()">확대(백워딩)미러링</a></li>
                            <li><a href="#" onclick="zoomOutImage()">축소미러링</a></li>
                            <li><a href="#" onclick="rotateImage()">회전미러링</a></li>
                            <li><a href="#" onclick="moveImage()">이동미러링</a></li>
                        </ul>
                        </div>
                    </li>
                    <li class="menu">
                      <a href="#">화소영역처리</a>
                      <div class="sub-menu-3">
                      <ul class="submenu">
                        <li><a href="#" onclick="embossImage()">엠보싱</a></li>
                        <li><a href="#" onclick="blurrImage()">블러링</a></li>
                        <li><a href="#" onclick="sharpening()">샤프닝</a></li>
                        <li><a href="#" onclick="OnHpfSharp()">고주파샤프닝</a></li>
                        <li><a href="#" onclick="horizon()">수평엣지</a></li>
                        <li><a href="#" onclick="vertical()">수직엣지</a></li>
                        <li><a href="#" onclick="gaussian()">가우시안필터</a></li>
                        <li><a href="#" onclick="OnHomogenOperator()">유사연산자 에지검출</a></li>
                        <li><a href="#" onclick="sharpening()">라플라스</a></li>
                      </ul>
                    </div>
                    </li>
                    <li class="menu">
                      <a href="#">히스토그램처리</a>
                      <div class="sub-menu-4">
                      <ul class="submenu">
                        <li><a href="#" onclick="stretchImage()">스트레칭</a></li>
                        <li><a href="#" onclick="endInImage()">엔트인</a></li>
                        <li><a href="#" onclick="equalizeImage()">평활화</a></li>
                      </ul>
                    </div>
                    </li>
                </ul>
            </div>
            <select name="pixel" class="pixel"  style="display:none;" onchange="selectAlgorithm(this.form.pixel)">
                <option value="0">*화소점 처리*</option>
                <option value="101">동일 영상</option>
                <option value="102">영상 반전</option>
                <option value="103">더하기</option>
                <option value="104">빼기</option>
                <option value="105">곱하기</option>
                <option value="106">나누기</option>
                <option value="107">흑백(평균값)</option>
                <option value="108">흑백(127)</option>
                <option value="109">감마</option>
                <option value="110">파라볼라(캡)</option>
                <option value="111">파라볼라(컵)</option>
            </select>
            <select name="geometry" class="geometry"  style="display:none;" onchange="selectAlgorithm(this.form.geometry)">
                <option value="0">*기하학 처리*</option>
                <option value="201">상하 미러링</option>
                <option value="202">좌우 미러링</option>
                <option value="203">확대 미러링</option>
                <option value="204">확대(백워딩) 미러링</option>
                <option value="205">축소 미러링</option>
                <option value="206">회전 미러링</option> <!--202-->
                <option value="207">이동 미러링</option>
            </select>
            <select name="area" class="area" style="display:none;"  onchange="selectAlgorithm(this.form.area)">
                <option value="0">*화소영역 처리*</option>
                <option value="301">엠보싱</option>
                <option value="302">블러링</option>
                <option value="303">샤프닝</option>
                <option value="304">고주파샤프닝</option>
                <option value="305">수평엣지</option>
                <option value="306">수직엣지</option>
                <option value="307">가우시안필터</option>
                <option value="308">유사연산자 에지검출</option>
                <option value="309">라플라스</option>
                </select>
            <select name="histo" class="histo"  style="display:none;" onchange="selectAlgorithm(this.form.histo)">
                <option value="0">*히스토그램 처리*</option>
                <option value="401">스트래칭</option>
                <option value="402">엔드인</option>
                <option value="403">평활화</option>
            </select>
            
        </form>
        <br>
        <div id="canvas" style="display:flex;">
            <div class="inCanvas" style="width:fit-content ; margin-right:20px">
            <h5 style="text-align:center ;">원본</h5>
            <canvas id="inCanvas" style="background-color: lightpink">
            </canvas>
            </div>
            <div class="outCanvas" style="width:fit-content ;">
            <h5 style="text-align:center ;">변환후</h5>
            <canvas id="outCanvas" style="background-color: lightblue"
           ></canvas></div>
        </div>
    </body>
</html>